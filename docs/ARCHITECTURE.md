# 分布式任务调度系统 - 架构设计文档

## 1. 系统概述

### 1.1 项目简介

本项目是一个基于Go语言实现的分布式任务调度系统，采用etcd作为分布式协调服务，支持任务优先级调度、负载均衡、故障恢复等核心功能。

### 1.2 核心特性

- **分布式架构**：支持多个调度器和工作节点的横向扩展
- **任务优先级**：支持多级优先级队列
- **负载均衡**：提供多种负载均衡策略（轮询、随机、最少负载、加权）
- **故障恢复**：自动检测节点故障并重新分配任务
- **任务重试**：支持任务失败后的自动重试机制
- **实时监控**：提供节点和任务状态监控

## 2. 系统架构

### 2.1 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      etcd 协调服务                            │
│                  (服务发现、任务存储、队列)                     │
└─────────────────────────────────────────────────────────────┘
         ▲                    ▲                    ▲
         │                    │                    │
    ┌────┴────┐          ┌────┴────┐          ┌────┴────┐
    │         │          │         │          │         │
┌───┴───┐ ┌──┴───┐  ┌───┴───┐ ┌──┴───┐  ┌───┴───┐ ┌──┴───┐
│调度器1│ │调度器2│  │工作节点1│ │工作节点2│ │工作节点3│ │工作节点N│
└───────┘ └──────┘  └───────┘ └───────┘ └───────┘ └───────┘
```

### 2.2 核心组件

#### 2.2.1 调度器 (Scheduler)

**职责：**
- 接收任务提交
- 将任务加入优先级队列
- 从队列中取出任务并分配给工作节点
- 监控任务执行状态
- 处理任务失败和重试

**关键特性：**
- 支持多个调度器实例（高可用）
- 自动负载均衡任务分配
- 监控工作节点状态
- 自动故障恢复

#### 2.2.2 工作节点 (Worker)

**职责：**
- 从队列中拉取任务
- 执行任务
- 上报任务执行结果
- 上报节点负载状态

**关键特性：**
- 支持并发任务执行
- 任务执行器注册机制
- 自动重试失败任务
- 资源使用监控

#### 2.2.3 协调器 (Coordinator)

**职责：**
- 节点注册和服务发现
- 任务存储和管理
- 任务队列管理
- 分布式锁

**实现：**
- 基于etcd实现
- 使用lease机制保证节点在线状态
- 使用有序key实现优先级队列

#### 2.2.4 任务队列 (Queue)

**职责：**
- 任务入队和出队
- 优先级管理
- 队列状态监控

**实现：**
- 基于etcd的有序key实现
- 支持多级优先级
- 线程安全的并发访问

#### 2.2.5 负载均衡器 (LoadBalancer)

**支持的策略：**
- **轮询 (Round Robin)**：依次分配任务
- **随机 (Random)**：随机选择节点
- **最少负载 (Least Load)**：选择负载最低的节点
- **加权 (Weighted)**：根据节点权重分配

## 3. 数据流

### 3.1 任务提交流程

```
客户端 → 调度器 → etcd(任务存储) → etcd(任务队列)
```

1. 客户端提交任务到调度器
2. 调度器将任务序列化后存储到etcd
3. 调度器将任务ID加入优先级队列

### 3.2 任务执行流程

```
调度器 → 选择工作节点 → 更新任务状态 → 工作节点拉取任务 → 执行任务 → 更新结果
```

1. 调度器从队列中取出任务
2. 通过负载均衡器选择工作节点
3. 更新任务状态为运行中
4. 工作节点从队列拉取任务
5. 工作节点执行任务
6. 工作节点更新任务执行结果

### 3.3 故障恢复流程

```
节点下线 → 检测到故障 → 重新分配任务 → 重新入队
```

1. 工作节点下线或故障
2. 调度器通过心跳检测到故障
3. 调度器找到分配给该节点的任务
4. 将任务重新加入队列

## 4. 存储设计

### 4.1 etcd Key设计

```
/nodes/scheduler/{node_id}      # 调度器节点信息
/nodes/worker/{node_id}          # 工作节点信息
/tasks/{task_id}                 # 任务数据
/queues/{queue_name}/priority_{priority}_{timestamp}_{task_id}  # 队列
/locks/{lock_key}                # 分布式锁
```

### 4.2 任务数据结构

```go
type Task struct {
    ID          string                 // 任务ID
    Name        string                 // 任务名称
    Type        string                 // 任务类型
    Status      TaskStatus             // 任务状态
    Priority    Priority               // 优先级
    Payload     map[string]interface{} // 任务数据
    Metadata    map[string]string      // 元数据
    CreatedAt   time.Time              // 创建时间
    StartedAt   *time.Time             // 开始时间
    CompletedAt *time.Time             // 完成时间
    WorkerID    string                 // 执行的工作节点ID
    RetryCount  int                    // 重试次数
    MaxRetries  int                    // 最大重试次数
    Timeout     time.Duration          // 超时时间
    Result      interface{}            // 执行结果
    Error       string                 // 错误信息
}
```

## 5. 并发控制

### 5.1 任务分配

- 使用etcd的事务机制保证任务分配的原子性
- 多个调度器可以同时工作，通过队列机制避免任务重复分配

### 5.2 节点状态

- 使用etcd的lease机制自动清理下线节点
- 定期心跳更新节点状态

### 5.3 分布式锁

- 使用etcd实现分布式锁
- 用于保证关键操作的互斥性

## 6. 可扩展性设计

### 6.1 水平扩展

- **调度器扩展**：可以启动多个调度器实例，通过队列共享任务
- **工作节点扩展**：可以动态添加工作节点，自动加入集群

### 6.2 性能优化

- **批量处理**：调度器批量从队列中取任务
- **异步执行**：工作节点异步执行任务
- **连接池**：etcd客户端使用连接池复用连接

## 7. 容错设计

### 7.1 节点故障

- **调度器故障**：其他调度器可以继续工作
- **工作节点故障**：任务自动重新分配

### 7.2 任务失败

- **自动重试**：支持配置最大重试次数
- **重试策略**：失败任务重新入队

### 7.3 数据一致性

- 使用etcd保证数据一致性
- 任务状态变更通过etcd同步

## 8. 监控和运维

### 8.1 统计信息

- 调度器统计：总任务数、队列长度、运行中任务数、完成/失败任务数
- 工作节点统计：总任务数、运行中任务数、CPU/内存使用率

### 8.2 日志

- 使用zap进行结构化日志记录
- 记录关键操作和错误信息

## 9. 技术栈

- **语言**：Go 1.21+
- **协调服务**：etcd v3.5
- **日志**：zap
- **序列化**：JSON

## 10. 部署架构

### 10.1 部署方式

系统支持两种部署方式：

#### 10.1.1 Docker Compose 部署（推荐）

**优势：**
- 一键启动，快速部署
- 环境隔离，依赖清晰
- 易于扩展和管理
- 适合开发、测试和生产环境

**默认配置：**
- 1个etcd节点（容器化）
- 1个调度器实例（容器化）
- 3个工作节点实例（容器化）

**启动命令：**
```bash
docker-compose up -d
```

**服务说明：**
- `etcd`: etcd服务，端口2379（客户端）、2380（节点间通信）
- `scheduler`: 调度器服务
- `worker-1`, `worker-2`, `worker-3`: 工作节点服务
- `client`: 客户端服务（按需运行）

**扩展方式：**
- 修改 `docker-compose.yml` 添加更多服务
- 使用 `docker-compose up -d --scale worker-1=N` 扩展工作节点
- 使用 `docker-compose.override.yml` 自定义配置

#### 10.1.2 本地编译部署

**优势：**
- 完全控制配置
- 适合生产环境定制
- 性能调优更灵活

**最小部署：**
- 1个etcd节点
- 1个调度器实例
- N个工作节点实例

**高可用部署：**
- 3个或更多etcd节点（集群）
- 2个或更多调度器实例
- N个工作节点实例（根据负载调整）

### 10.2 Docker Compose 架构图

```
┌─────────────────────────────────────────┐
│         Docker Compose Network          │
│                                         │
│  ┌──────────┐    ┌──────────┐          │
│  │  etcd    │    │ scheduler│          │
│  │ :2379    │◄───┤          │          │
│  └────┬─────┘    └──────────┘          │
│       │                                 │
│       │    ┌──────────┐  ┌──────────┐  │
│       └───►│ worker-1 │  │ worker-2 │  │
│            └──────────┘  └──────────┘  │
│                                         │
│            ┌──────────┐                │
│            │ worker-3 │                │
│            └──────────┘                │
└─────────────────────────────────────────┘
```

### 10.3 生产环境建议

**Docker Compose 生产部署：**
- 使用外部etcd集群（3节点或更多）
- 配置资源限制（CPU、内存）
- 配置健康检查
- 使用持久化存储
- 配置日志收集
- 使用反向代理（如Nginx）

**本地编译生产部署：**
- etcd集群部署（3节点或更多）
- 调度器多实例部署（负载均衡）
- 工作节点根据负载动态扩展
- 配置监控和告警
- 配置日志聚合

